/*
This module contains all the wrapper functions than handle the returned output for all routes.

jsonRows, (insert,update,delete,upsert)_rows and mapRows are of the form [{}]
*/
function ProcessError(err) {
    try{
        if (! err.hasOwnProperty('errors')) {
            //thrown with new error
            return err.message
        }
        var errorList = [err.message]
        err.errors.forEach( (erx) => errorList.push(erx.message) )
        return errorList.join(" ")
    } catch (perr) {
        return "Failed to process error message" + perr.stack
    }    
}


module.exports = {

    //router fail. used to send if router failse
    RouterFail(table_name, route_name, router_route, err, res) {
        var err_msg_full = "Error bubbled up to router level. " + ProcessError(err)
        res.status(500).json( {'error_msg': err_msg_full, 'is_error': true, 'rows': [], 'table_name': table_name, 
            'route_name': route_name, 'router_route': router_route } )
    },
    //Process Error Message. new Error and Sequelize error have different structures.
    "ProcessError": ProcessError,

    /*
    ExtractNodeId pulls the row_node_id generated by ag-grid. This tracks which row the data is comming from
    on the client side
    */
    ExtractNodeId(data_row) {
        try {
            var tmp = parseInt(data_row['node_id'])
            if (isNaN(tmp) ){return -1} else{ return tmp} 
        } catch {
            return -1
        }

    },
    /*
    ExtractRowId pulls the id stored in each table. This is primary key for the location of the data in
    the database
    */
    ExtractRowId(data_row) {
        try {
            var tmp = parseInt(data_row['id'])
            if (isNaN(tmp) ) {return -1} else{ return tmp} 
        } catch {
            return -1
        }

    },
    /*
    QueryError and QuerrySuccess are wrappers for all get and custom get route return objects
    */
    QueryError(err_msg, table_name, route_name) { 
        return { 'error_msg': err_msg, 'is_error': true, 'rows': [], 'table_name': table_name, 'route_name': route_name } 
    },

    QuerySuccess(json_rows, table_name, route_name) { 

        return { 'error_msg': '', 'is_error': false, 'rows': json_rows, 'table_name': table_name, 'route_name': route_name } 
    
    },
    /*
    ModifyPass and ModifyFail are wrappers for all insert,update,delete and upsert return objects
    */
    ModifyPass (row_node_id,  row_id) {
        //crud_type: insert, delete, 
        return {'is_error': false, 'node_id': row_node_id,  'error_msg': '', 'id': row_id }

    },

    ModifyFail (row_node_id,   row_id, err_msg) {
        //try catch for error message?
        return {'is_error': true, 'node_id': row_node_id, 'error_msg': err_msg, 'id': row_id }

    },
    //parser for maps?
    //maybe send key instructions?
    ReturnMaps (table_name, route_name, map_rows) {
        return {'table_name': table_name, 'map_rows': map_rows, 'is_error': false, 'error_msg': '', 'route_name': route_name }
    },
    //parser for maps?
    ReturnMapError (table_name, route_name, map_rows, err_msg) {
        return {'table_name': table_name, 'map_rows': map_rows, 'is_error': true, 'error_msg': err_msg, 'route_name': route_name }
    },

    //this is the final output wrapper for insert/delete/update/upsert. This object gets send
    //to the client. May just send empty arrays for insert, update, upsert, and delete.
    //Maybe check if array first. othewise send empty array
    ReturnOutput(insert_rows, update_rows, delete_rows, upsert_rows, table_name, route_name) {
        output = {
            'error': {'is_error': false, 'error_msg': ''},
            'output': {
                'insert': insert_rows,
                'update': update_rows,
                'upsert': upsert_rows,
                'delete': delete_rows
            },
            'table_name': table_name,
            'route_name': route_name
        }
        return output
    },
    //this is the final output wrapper for insert/delete/update/upsert when an error occurs.. This object gets send
    //to the client. May just send empty arrays for insert, update, upsert, and delete.
    //Maybe check if array first. othewise send empty array
    ReturnOutputError(error_msg, insert_rows, update_rows, delete_rows, upsert_rows, table_name, route_name) {
        //if insert, update, upsert or delete are not arrays send empty list?
        var ix = []
        var ux = []
        var dx = []
        var upx = []
        if (Array.isArray(insert_rows)) {ix = insert_rows}
        if (Array.isArray(update_rows)) {ux = update_rows}
        if (Array.isArray(delete_rows)) {dx = delete_rows}
        if (Array.isArray(upsert_rows)) {upx = upsert_rows}

        output = {
            'error': {'is_error': true, 'error_msg': error_msg},
            'output': {
                'insert': ix,
                'update': ux,
                'upsert': upx,
                'delete': dx
            },
            'table_name': table_name,
            'route_name': route_name
        }
        return output
    },

    CreateColumnObject(table_map, calculated_field_map_list, calculated_like_fields, skip_timestamp=true) {
        /*
        Creates the columnObject which contains: columnMap, columnList and columnQuickSortString.

        Inputs:
            table_map: [{table_name: '', 'variable_names': []}] use the value in table_name and and appends it 
                with a period to all the variable_names.

            calculated_field_map_list: [{'variable_name':'name','calc_string':'raw postgres string'}
                given a variable_name that is actually generated by a calculations the calc_string will be
                sent to postgres where and order by clauses if thats used in the query request.

            calculated_like_fields: this is a list of strings. each string is a column or postgres calculation
                they are used for the quick sort parameter. As an example would be switching date columns into
                mm/dd/yyyy format so that a client string may match the date field.
            skip_timestamp: if true dont include created_at or updated_at in like string

            //date fields to convert for like string?? SELECT TO_CHAR(date, 'MM/DD/YYYY')

        Output:
            columnMap maps the variable names to the table.columnName in the postgres database. when
                the field is calculated it maps the variable_name to a string representation of the value
                to be calculated.
            columnList: list of all table.columnNames and calculation strings used
            columnQuickSortString: raw sql string that is used to concatentate all columns and calculated fields
                used in the like function to create a quick sort functionality


        variable_name, table_map {table_name: 'users', 'variable_names': []}
        */
        var columnMap  = {}
        var columnList = []
        var likeColumns = []
        for (table_map_row of table_map ) {
            var table_name = table_map_row['table_name']
            var variable_list = table_map_row['variable_names']
            for (variable_name of variable_list) {
                var columnName = table_name +'.' +variable_name
                columnMap[variable_name] = columnName
                columnList.push(columnName)
                if (skip_timestamp) {
                    if (variable_name == 'created_at' || variable_name == 'updated_at' ) {continue} 
                }
                likeColumns.push(columnName + '::text')
            }
        }

        for (valx of calculated_field_map_list) {
            var columnName = valx['calc_string']
            columnMap[valx['variable_name']] = columnName
            columnList.push(columnName)
            likeColumns.push(columnName)
        }
        for (valx of calculated_like_fields) {
            likeColumns.push(valx)
        }
        
        columnObject = {
            'columnMap': columnMap,
            'columnList': columnList,
            'columnQuickSortString': likeColumns.join(' || ')
        }
        return columnObject
    }
}