/*
It looks like you may have been close based on your comment to @ebohlman's answer. 
You can use WHERE id = ANY($1::int[]). PostgreSQL will convert the array to the type the parameter is cast to in $1::int[].
So here's a contrived example that works for me:

Is type conversion necessary? probably

https://stackoverflow.com/questions/10720420/node-postgres-how-to-execute-where-col-in-dynamic-value-list-query


OPERATORS: 

=	Equal
>	Greater than
<	Less than
>=	Greater than or equal
<=	Less than or equal
<> or !=	Not equal
AND	Logical operator AND
OR	Logical operator OR
IN	Return true if a value matches any value in a list
BETWEEN	Return true if a value is between a range of values
NOT BETWEEN 
LIKE	Return true if a value matches a pattern
IS NULL	Return true if a value is NULL
NOT	Negate the result of other operators

a BETWEEN x AND y
a NOT BETWEEN x AND y
BETWEEN SYMMETRIC (does automatic swap)





This module is used to help assemble the where, order_by and pagination statements for a given get request.
CreateQueryParams is the main modules that returns the query filtering and sorting conditions string that is attached
to the final sql query sent to the database.

Key variables and definitions:
variable_name: this field contains the name of the column sent to the client side and displayed by the client
    side grid
columnMap: The column map object converts the variable_name to its full refrenced name in the sequel query being assembled.
    For example id -> departments.id where id belongs to the departments table. For calculated fields i.e cfte it will
    replace the variable_name with the funciton used to create the value .calculated_field: refers to columns that are generated by calculations 
        and are not actually stored in a table. Each route will have defined functions for creating the variable_name -> calculated filed mapping.

replacements: this is an object that stores the names and values used to replace values in the sql template string.
    i.e. {'ids': [1,2,3]} with 'SELECT * FROM users where id in (:ids)' -> SELECT * FROM users where id in (1,2,3)
    the column is used to designate what should be replaced in the template string with corresponding key value pairs
    in the sql template string.

req_body: this is an object for req.body which is sent from the client during the post request it can have several
objects for get routes it will have the objects:
req.body['rules'] = [{}] //rules contain informations such as include read only.
req.body['where'] = [{}]
req.body['order_by'] = [{}]
req.body['pagination'] = [{}]

and for transactions i.e. insert/update/upsert/delete it will have
req.body['insert'] = [{}]
req.body['update'] = [{}]
req.body['upsert'] = [{}]
req.body['delete'] = [{}]

GET: For get request the four major components are rules, where, order_by and pagination. This data is sent
from the client or generated by there server to create the sql query restraints and filters.

req.body['where'] contains a json list of data used to create the where statement. All json rows in
the where object are joined by an AND statement.
where: json list [{'variable_name': , 'query_type': , 'value':  , 'data_type': ''}]

variable_name: this field contains the name of the column sent to the client side and displayed by the client
    side grid

value: the actual value to insert into the query string. This can be a single value or a list of values.
    if date_type is 'date' the value will be of type {'before_date': YYYY-MM-DD, 'after_date': YYYY-MM-DD}
    the value may contain either before_date or after_date or both dates. for server_query its the full boolean string
    argument.
    for numerical values the value type will be of {'value_1': xx, 'value_2': xx, 'value_list': []}
        value_1 is used by default. value 2 is used for between and not_between.

data_type: string, float, int, etc. Determines what the value type should be in the value object or a list of data.
    used to do a final conversion check?

    //attempt type cast and filter. //data_types // integer, float, date, string, boolean


query_type: this specifies how the row will pe processed to create the binary sql string component.
    types are: in, date, like, equals, quick_filter, server_query, greater_equal, greater, less, less_equal, between, not_between

    in: the in flag is meant to create a statement like id in (1,2,3,4,5). the value should be a list of values
    date: the date field expects the value object to be {'before_date': '2020-11-01', 'after_date':'1999-01-01'}
        the date value is in YYYY-MM-DD format. Either or both before_date and after_date can be present. 
        the output statement will look like "effective_date >=  '1999-01-01' and effective_date <=  '2020-11-01'
    equals: checks 'columnName = value' for string
    quick_filter: this is similar to the like clause, but all columns names in the columnMap are concatenated together
        so that the quick_filter value is compared against all columns in a row.


    like: uses the like operater 'columnName like value or value like columnName'
    greater, greater_equal, less, less_equal: used to compare numerical values. creates bool statement like 'columnName < value'

    server_query: this is a query string generated by the server. If variable_name and value are not null they are added
        to the replacements object. the string is in the query_string object in the where rows.

req.body['order_by']: this contains a json list to determine to order in which to return the data.
    req.body['order_by'] = [{ 'variable_name': 'id', 'sort_order': asc },{ 'variable_name': 'first_name', 'sort_order': desc } ] 
    this would create a statemente as follows
        columnName = columnMap['variable_name']
        'ORDER BY department.id asc, provider.first_name desc'

req.body['rules'] = [{}] used for creating different queries. read_only for example.

req.body['pagination']: this contains values for offset and limit. This creates pagination for the query 
    req.body['pagination']= {'offset': 0, 'limit': 1000} creates statement
        'offset 0 limit 1000'


TRANSACTIONS: INSERT, UPDATE, UPSERT, DELETE
For save request i.e. insert/update/upsert/delete there will be five objects in req.body

//save
req.body['insert'] = [{}]
req.body['update'] = [{}]
req.body['upsert'] = [{}]
req.body['delete'] = [{}]



//output return from server
server_error: {'is_error':true, 'msg': 'what happened'} //for actual server side errors?
get_error: {'is_error':true, 'msg': 'what happened'} //maybe for permissions issues??
output: [{}] //list of id, row_node_id and error_msg: '' add error message and filter on client side.

*/
//user filter. boolean string for user permissions included in where statement?
const moment = require('moment')
//module.exports = {}
//columnObject = {columnMap, columnList, columnQuickSortString }

function CreateQueryParamaters(req, columnObject) {
    // var user_id = req_body['user_id']
    // var columnMap = columnObject['columnMap']
    // var columnList = columnObject['columnList']
    // var columnQuickSortString = columnObject['columnQuickSortString']
    //
    var req_body = req['body']
    CheckReqBodyArguments(req_body)
    var where_statements = req_body['where']
    var sort_statements = req_body['order_by']
    var pagination_values = req_body['pagination']
    var replacementObject = {}

    //need to parse rules statement. and add to where for is_active.
    //and generate read_only statement. Also need a boolean flag for where clause
    var where_string = WhereClause(where_statements, columnObject, replacementObject)
    var sort_string  = OrderClause( sort_statements, columnObject['columnMap'] )
    var pagination_string = PaginationClause(pagination_values)
    var outer_string = OuterQuery(where_statements, columnObject, replacementObject)

    //add user id
    replacementObject['user_id'] = er.ExtractUserId(req)
    // var query_restraints_string = `${where_string}
    // ${sort_string}
    // ${pagination_string}`

    var query_restraints = {'query_options': {
        'where': where_string,
        'order_by': sort_string,
        'pagination': pagination_string,
        'outer_statement': outer_string,
        'replacements': replacementObject
    } }
    return query_restraints

    //concat where, sort and pagination string??
}

function IsEmptyStatement(processedValue) {
    /*
    Checks if a value is null or array is empty. If either true return true
    else return false
    */
    if (processedValue === null) { return true }
    if (Array.isArray(processedValue)) {
        if (processedValue.length == 0 ) {
            return true
        } else {
            return false
        }
    }
    if (typeof processedValue === 'string' || processedValue instanceof String  ) {
        if (processedValue.trim() == '') {return true}
    }
    return false
}


// module.exports = {}